Table users {
  id uuid [pk, default: `gen_random_uuid()`]
  name varchar(255) [not null]
  email varchar(255) [unique, not null]
  email_verified_at timestamp
  password varchar(255) [not null]
  remember_token varchar(100)
  created_at timestamp [not null, default: `now()`]
  updated_at timestamp [not null, default: `now()`]

  Note: 'Laravel Breeze authentication users'
}

Table notes {
  id uuid [pk, default: `gen_random_uuid()`]
  user_id uuid [ref: > users.id, not null]
  title varchar(255) [not null, note: 'Defaults to timestamp if not provided']
  created_at timestamp [not null, default: `now()`]
  updated_at timestamp [not null, default: `now()`]

  Note: 'Container for voice notes, can have multiple audio recordings'

  indexes {
    user_id [name: 'idx_notes_user_id']
    created_at [name: 'idx_notes_created_at']
    (user_id, created_at) [name: 'idx_notes_user_created']
  }
}

Table audio_files {
  id uuid [pk, default: `gen_random_uuid()`]
  note_id uuid [ref: > notes.id, not null]
  path text [not null, note: 'Filesystem path to .webm file (storage/app/audio/{note_id}/{uuid}.webm)']
  duration_seconds integer [note: 'Audio duration for UI display']
  file_size_bytes bigint [note: 'File size for storage management']
  mime_type varchar(50) [default: 'audio/webm', note: 'Audio format']
  created_at timestamp [not null, default: `now()`]

  Note: 'References to audio files stored on filesystem'

  indexes {
    note_id [name: 'idx_audio_files_note_id']
    created_at [name: 'idx_audio_files_created_at']
  }
}

//// CHUNKS ////
Table chunks {
  id uuid [pk, default: `gen_random_uuid()`]
  note_id uuid [ref: > notes.id, not null]
  audio_id uuid [ref: > audio_files.id, note: 'Optional: links chunk to specific recording']
  dictation_text text [note: 'Raw browser dictation API output']
  ai_text text [note: 'AI-refined version using Gemini 2.5 Flash']
  edited_text text [note: 'User-edited final version']
  active_version varchar(10) [not null, default: 'dictation', note: 'dictation | ai | edited']
  chunk_order integer [not null, default: 0, note: 'Order of chunk within note']
  created_at timestamp [not null, default: `now()`]
  updated_at timestamp [not null, default: `now()`]

  Note: 'Editable text blocks linked to audio or manually created'

  indexes {
    note_id [name: 'idx_chunks_note_id']
    audio_id [name: 'idx_chunks_audio_id']
    (note_id, chunk_order) [name: 'idx_chunks_note_order']
    active_version [name: 'idx_chunks_active_version']
  }
}


//// VECTOR EMBEDDINGS ////
Table vector_embeddings {
  id uuid [pk, default: `gen_random_uuid()`]
  note_id uuid [ref: > notes.id, not null]
  audio_id uuid [ref: > audio_files.id, note: 'Optional: specific audio source']
  chunk_ids uuid[] [note: 'Array of chunk IDs included in this embedding']
  qdrant_point_id uuid [unique, not null, note: 'Reference to Qdrant vector point']
  source_text text [not null, note: 'Text content that was vectorized']
  embedding_model varchar(100) [default: 'models/embedding-001', note: 'AI model used for embeddings']
  text_hash varchar(64) [note: 'SHA-256 hash for change detection (re-embed if >20% diff)']
  created_at timestamp [not null, default: `now()`]
  updated_at timestamp [not null, default: `now()`]

  Note: 'Metadata for vector embeddings stored in Qdrant for semantic search'

  indexes {
    note_id [name: 'idx_vector_embeddings_note_id']
    audio_id [name: 'idx_vector_embeddings_audio_id']
    qdrant_point_id [name: 'idx_vector_embeddings_qdrant_id', unique]
    text_hash [name: 'idx_vector_embeddings_hash']
  }
}

